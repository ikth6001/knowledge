<h3>리눅스</h3>

<h4>리눅스 OS의 구조</h4>

![LinuxStructure](images/linux/linuxStructure.png?raw=true "LinuxStructure")

<br>
<br>

<h4>리눅스 파티셔닝</h4>
리눅스 설치 시, 메모리 파티셔닝은 루트 영역과 swap 영역만 있어도 문제없이 사용할 수 있다. 하지만 일반적으로 아래와 같은 용도로 나누어 파티셔닝을 해서 사용한다.

* / : 루트 파티션
* /boot : 부팅 커널이 저장되는 영역
* /usr : 응용 프로그램이 저장되는 영역
* /tmp : 임시 파일이 저장되는 영역
* /var : 로그, 캐시파일이 저장되는 영역
* /home : 사용자별 데이터가 저장되는 영역
* swap : RAM 용량 부족 시 사용되는 


<br>
<br>

<h4>서버 구축시 알아야 할 필수 개념 및 명령어</h4>

* 터미널/콘솔에서 시스템 종료 명령 : poweroff, shutdown -P now, shutdown -P +10 ( 10분 후 종료 ), halt -p, init 0
* 유닉스/리눅스의 프롬프트 표식을 통해 현재 접속 유저가 루트인지 일반 사용자인지 알 수 있다. 루트면 #, 사용자는 $ 모양이다.
* 시스템 재부팅 명령 : shutdown -r now, reboot, init 6
* 로그아웃 : 시스템 종료가 아닌 현재 사용자를 종료한다는 의미. logout, exit
* 사용자 로그아웃 처리 : 루트가 시스템 관리를 위해 사용자를 로그아웃 하도록 유도하는 기능으로 거짓 시스템 종료 메시지를 전송한다. shutdown -k +10
* 런레벨 : 리눅스는 시스템이 가동되는 방법을 7가지 런레벨로 나눈다. 즉 시스템 종료 명령 중 init 0은 시스템 실행 레벨을 0번 종료모드로 변경하라는 의미가 되어 시스템을 종료하는 것이다.
  * 0 : 종료 모드
  * 1 : 시스템 복구 모드
  * 2 : 다중 사용자 모드. 사용 안 함
  * 3 : 텍스트 모드의 다중 사용자 모드
  * 4 : 다중 사용자 모드. 사용 안 함
  * 5 : 그래픽 모드의 다중 사용자 모드
  * 6 : 재 시작
* 스왑(swp) 파일 : vi 에디터를 통해 수정 중 비정상적으로 종료되면 생기는 파일이다. vi 에디터로 파일을 열면 ${파일명}.swp 파일이 생성되고 에디터를 정상 종료 하면 다시 삭제 되는데 비정상 종료되어 남는 것이다. 이 경우 swp 파일을 삭제하면 된다.
* vi 에디터 명령어
  * i : 현재 커서 위치에서 명령 모드에서 입력 모드로 변경
  * I : 현재 커서위치 라인에서 맨 앞으로 이동 후 입력 모드로 변경
  * a : 현재 커서의 다음 칸에서 입력 모드로 변경
  * A : 현재 커서위치 라인에서 맨 뒤로 이동 후 입력 모드로 변경
  * h, k, l, j : 순서대로 커서 왼쪽,위,오른쪽,아래로 한칸 이동
  * ^ : 현재 행의 처음으로 이동
  * $ : 현재 행의 마지막으로 이동
  * gg : 제일 첫 행으로 이동
  * G : 제일 끝 행으로 이동
  * 숫자 + G : 해당 숫자 행으로 이동
  * :숫자 + 엔터 : 해당 숫자 행으로 이동
  * x : 현재 커서 위치한 클 삭제
  * dd : 현재 커서 위치한 행 삭제
  * yy : 현재 커서 위치한 행 복사
  * p : 복사한 내용을 현재 행 이후에 붙여넣기
  * /문자열 + 엔터 : 문자열 검색
  * n : 찾은 문자 중에서 다음 문자로 이동
  * 문자열 치환 : :%s/기존문자열/변경문자열
  * :set number : 에디터의 앞에 라인 행 번호 표시
* 도움말 : 리눅스 명령어를 검색하는 명령어. man
* 마운트 : CD/DVD, USB와 같은 물리적인 장치를 특정한 위치(대개 디렉토리)에 연결시키는 과정으로, 윈도우에서는 필요 없지만 리눅스에서는 추가적인 물리 장치 사용시 마운트를 해주어야 한다.
* 마운트 정보 확인 명령어 : mount
* 기존 마운트 해제 명령어 : umount + ${장치명 또는 디렉토리명}
* 리눅스 기본 명령어
  * ls : List 약자로 디렉터리 내의 파일 목록을 나열한다.
  * pwd : 현재 디렉토리의 절대 경로를 보여준다.
  * cd : 디렉토리 이동. 리눅스에서 상위 디렉토리는 .. 으로 나타내고 현재 디렉토리는 . 으로 나타낸다.
  * rm : 명시된 디렉토리 또는 파일을 삭제한다. (권한이 있을 경우)
  * cp : 파일이나 디렉토리를 복사한다. 새로 복사한 파일은 복사한 사용자의 소유가 된다. cp 명령을 사용할 땐 해당 파일의 읽기 권한이 있어야 한다.
  * touch : 크기가 0인 파일을 생성하거나 파일이 존재할 경우 최종 수정 시간을 현재 시간으로 변경한다.
  * mv : 파일이나 디렉터리의 이름을 변경하거나 다른 디렉터리로 옮길 때 사용한다.
  * mkdir : 디렉토리를 새로 만드는 명령어로 실행한 사용자 소유가 도니다.
  * rmdir : 디렉토리를 삭제하는 명령어로 디렉토리 삭제 권한이 있어야 한다.
  * cat : 파일의 내용을 화면에 보여준다.
  * head : 파일의 앞 N행을 보여준다. e.g. head -3 test.txt
  * tail : 파일의 마지막 N행을 보여준다.
  * more : 텍스트 형식 파일을 페이지 단위로 화면에 출력한다. Space를 누르면 다음 페이지 이동, B를 누르면 앞 페이지 이동, Q를 누르면 종료한다.
  * less : more의 확장 기능으로 화살표, Page up, down 키도 사용할 수 있다.
  * file : 해당 파일이 어떤 종류의 파일인지 표시 해준다.
  * clear : 터미널 화면을 깨끗하게 지워준다.
* 사용자 관리  
사용자는 그룹으로 묶일 수 있다. 사용자 정보는 /etc/passwd 파일을 통해 확인할 수 있다. passwd를 보면 각 행이 다음과 같은 형식으로 작성된다.  
**사용자이름:암호:사용자ID:사용자그룹ID:전체이름:홈디렉터리:기본셸**  
예를 들면 다음과 같다.  
centos : x : 1000 : 1000 : centos : /home/centos : /bin/bash  
centos 사용자의 암호는 /etc/shadow 파일에 저장되어 있고(:x 사용자 및 그룹 아이디는 1000 등등을 나타낸다.  
유저를 새로 생성하면 유저의 홈 디렉토리는 /etc/skel 하위 파일들을 복사하여 그대로 생성한다. 따라서 유저의 기본 디렉토리 구조를 변경하고 싶다면 /etc/skel을 변경하면 된다.
* 그룹 관리  
그룹은 /etc/group 파일에서 관리한다. 다음과 같은 형식으로 정의한다.  
**그룹이름:비밀번호:그룹ID:그룹에속한사용자이름**  
* 사용자 및 그룹 관리 명령어
  * useradd : 새로운 사용자를 추가한다.
  * passwd : 사용자의 비밀번호를 지정하거나 변경한다.
  * usermod : 사용자의 속성을 변경한다.
  * userdel : 사용자를 삭제한다.
  * change : 사용자의 암호를 주기적으로 변경하도록 설정한다.
  * groups : 사용자가 소속된 그룹을 보여준다.
  * groupadd : 새로운 그룹을 생성한다.
  * groupmod : 그룹의 속성을 변경한다.
  * groupdel : 그룹을 삭제한다.
* 파일과 디렉터리의 소유와 허가권
리눅스에서 파일의 상세 정보는 아래와 같은 방식으로 보여준다.  
**[파일유형][파일 허가권][링크 수][파일소유자명][파일소유그룹명][파일크기][마지막변경날짜][파일명]**  
  * 파일유형 : 파일의 종류를 포현.
    * 디렉터리 : d
    * 일반파일 : -
    * 블록디바이스(하드디스크, 플로피디스크 등등) : b
    * 문자디바이스(마우스, 키보드, 프린터 등등) : c
    * 링크(윈도우의 바로가기와 비슷한 개념) : l
  * 파일허가권
  파일 허가권은 3자리씩 끊어서 인식하면 된다. rwx로 각각 읽기, 쓰기, 실행 권한을 나타내며 총 9자리로 소유자, 그룹, 그외 사용자 3 분류로 나누어 각각 파일에 대한 허가권을 나타낸다. 3자리를 각각 2진수로 1, 0으로 나타낸 후 10진수로 계산한 값으로 설정 해준다.  
  참고로 디렉터리로 이동하려면 실행 권한이 반드시 있어야 한다.
* 링크  
  * 하드링크 : 파일의 메타 데이터를 공유하는 링크. 즉, 원본 파일의 경로가 옮겨져도 하드링크는 그대로 유지된다.
  * 소프트링크 : 파일의 메타 데이터를 공유 안하고 가리키는 포인터 객체. 즉, 원본 파일의 경로가 옮겨지면 가리키는 경로가 잘못되어 연결이 안된다.
* 리눅스 관리자를 위한 명령어
  * RPM : 초창기 리눅스는 간단한 프로그램 설치도 굉장히 어려웠다. 때문에 윈도우의 setup.exe처럼 쉽게 설치할 수 있는 파일을 제작했는데 이 파일의 확장자가 rpm이며 이를 패키지라고 불렀다.  
  일반적으로 **패키지이름-버전-릴리즈번호.CentOS버전.아키텍처.rpm** 형식으로 이름이 구성된다. 여기서 아키넥처는 x86_64(x86계열의 64비트 CPU를 의미), i386(구형 CPU)와 같은 값을 의미한다.  
  rpm의 가장 큰 단점은 의존성 문제이다. 리눅스에 웹브라우저 FireFox를 설치하고자 할 때 X윈도가 설치 안되어있다면?? 이러한 의존성 관리를 사용자가 전부 해줘야 한다는 점이다.
  * YUM : yum은 rpm의 단점을 극복한 명령어로 특정 패키지를 설치하고자 할 대 의존성이 있는 다른 패키지를 자동으로 먼저 설치해주는 명령어이다. 또한 rpm은 미리 DVD나 인터넷에서 파일을 다운로드 해야하지만 YUM은 rpm 파일 저장소에서 자동 다운로드한 후 설치 해준다.
    * yum install 패키지명 : 패키지를 설치하는 명령어
    * yum check-update : 패키지 중 업데이트 가능한 패키지 목록 출력
    * yum update 패키지명 : 패키지 업데이트. yum install을 사용하면 자동 업데이트 되므로 사용 잘 안함.
    * yum remove 패키지명 : 패키지 삭제.
    * yum info 패키지명 : 패키지 요약 정보를 출력한다.
  * YUM 설정 파일
    * /etc/yum.repos.d : yum 명령어 실행 시 패키지 파일을 검색하는 리포지토리 주소가 들어있는 파일.
    * /etc/yum.conf
  * YUM 작동 방식
    1. yum install을 통해 패키지 설치 명령을 내린다.
    2. /etc/yum.repos.d 디렉토리의 repo 파일을 확인한다. (대표적으로 CentOS-Base.repo) 이 파일에는 패키지 저장소 주소가 적혀있다.
    3. 저장소로 전체 패키지 목록 파일을 요청한다.
    4. 패키지 파일 목록을 응답 받으면 목록을 다운로드 한다.
    5. 설치할 패키지와 관련된 패키지의 이름을 화면에 출력해 설치 여부를 입력 받는다.
    6. 사용자가 Y를 입력하면 설치에 필요한 패키지 파일을 요청한다.
    7. 패키지 파일을 응답받으면 다운로드 후 설치한다.
  * /etc/yum.repos.d 파일의 구성내용
    * 식별자 : repository의 종류를 명시한다. [base]는 기본 저장소, [updates]는 패키지 업데이트에 사용되는 저장소, [extras], [centosplus]를 기타 패키지라고만 이해하자.
    * name : 저장소의 이름을 의미한다.
    * baseurl : 기본 저장소로 http, ftp, file 중 한 가지 프로토콜을 사용한다.
    * mirrorlist : baseurl이 설정 안되어 있으면 mirrorlist중 적절한 저장소를 골라 사용한다.
    * gpgcheck : GPG 서명(rpm 패키지를 인증하는 암호화된 서명)을 확인 할지 여부 설정. 1은 사용, 0은 사용 안함
    * cpgkey : GPG키가 들어있는 저장소 URL
    * enabled : 이 저장소를 사용할지 여부 설정. 1은 사용, 0
  
  
  
    





<br>
<br>

<h4></h4>

<br>
<br>

<h4></h4>

<br>
<br>

<h4></h4>

<br>
<br>

<h4></h4>

<br>
<br>


<h4></h4>

<br>
<br>

<h4></h4>

<br>
<br>

<h4></h4>

<br>
<br>

<h4></h4>

<br>
<br>

<h4></h4>

<br>
<br>

<h4></h4>

<br>
<br>

<h4></h4>

<br>
<br>

