<h3>리눅스</h3>

<h4>리눅스 OS의 구조</h4>

![LinuxStructure](images/linux/linuxStructure.png?raw=true "LinuxStructure")

<br>
<br>

<h4>리눅스 파티셔닝</h4>
리눅스 설치 시, 메모리 파티셔닝은 루트 영역과 swap 영역만 있어도 문제없이 사용할 수 있다. 하지만 일반적으로 아래와 같은 용도로 나누어 파티셔닝을 해서 사용한다.

* / : 루트 파티션
* /boot : 부팅 커널이 저장되는 영역
* /usr : 응용 프로그램이 저장되는 영역
* /tmp : 임시 파일이 저장되는 영역
* /var : 로그, 캐시파일이 저장되는 영역
* /home : 사용자별 데이터가 저장되는 영역
* swap : RAM 용량 부족 시 사용되는 


<br>
<br>

<h4>서버 구축시 알아야 할 필수 개념 및 명령어</h4>

* 터미널/콘솔에서 시스템 종료 명령 : poweroff, shutdown -P now, shutdown -P +10 ( 10분 후 종료 ), halt -p, init 0
* 유닉스/리눅스의 프롬프트 표식을 통해 현재 접속 유저가 루트인지 일반 사용자인지 알 수 있다. 루트면 #, 사용자는 $ 모양이다.
* 시스템 재부팅 명령 : shutdown -r now, reboot, init 6
* 로그아웃 : 시스템 종료가 아닌 현재 사용자를 종료한다는 의미. logout, exit
* 사용자 로그아웃 처리 : 루트가 시스템 관리를 위해 사용자를 로그아웃 하도록 유도하는 기능으로 거짓 시스템 종료 메시지를 전송한다. shutdown -k +10
* 런레벨 : 리눅스는 시스템이 가동되는 방법을 7가지 런레벨로 나눈다. 즉 시스템 종료 명령 중 init 0은 시스템 실행 레벨을 0번 종료모드로 변경하라는 의미가 되어 시스템을 종료하는 것이다.
  * 0 : 종료 모드
  * 1 : 시스템 복구 모드
  * 2 : 다중 사용자 모드. 사용 안 함
  * 3 : 텍스트 모드의 다중 사용자 모드
  * 4 : 다중 사용자 모드. 사용 안 함
  * 5 : 그래픽 모드의 다중 사용자 모드
  * 6 : 재 시작
* 스왑(swp) 파일 : vi 에디터를 통해 수정 중 비정상적으로 종료되면 생기는 파일이다. vi 에디터로 파일을 열면 ${파일명}.swp 파일이 생성되고 에디터를 정상 종료 하면 다시 삭제 되는데 비정상 종료되어 남는 것이다. 이 경우 swp 파일을 삭제하면 된다.
* vi 에디터 명령어
  * i : 현재 커서 위치에서 명령 모드에서 입력 모드로 변경
  * I : 현재 커서위치 라인에서 맨 앞으로 이동 후 입력 모드로 변경
  * a : 현재 커서의 다음 칸에서 입력 모드로 변경
  * A : 현재 커서위치 라인에서 맨 뒤로 이동 후 입력 모드로 변경
  * h, k, l, j : 순서대로 커서 왼쪽,위,오른쪽,아래로 한칸 이동
  * ^ : 현재 행의 처음으로 이동
  * $ : 현재 행의 마지막으로 이동
  * gg : 제일 첫 행으로 이동
  * G : 제일 끝 행으로 이동
  * 숫자 + G : 해당 숫자 행으로 이동
  * :숫자 + 엔터 : 해당 숫자 행으로 이동
  * x : 현재 커서 위치한 클 삭제
  * dd : 현재 커서 위치한 행 삭제
  * yy : 현재 커서 위치한 행 복사
  * p : 복사한 내용을 현재 행 이후에 붙여넣기
  * /문자열 + 엔터 : 문자열 검색
  * n : 찾은 문자 중에서 다음 문자로 이동
  * 문자열 치환 : :%s/기존문자열/변경문자열
  * :set number : 에디터의 앞에 라인 행 번호 표시
* 도움말 : 리눅스 명령어를 검색하는 명령어. man
* 마운트 : CD/DVD, USB와 같은 물리적인 장치를 특정한 위치(대개 디렉토리)에 연결시키는 과정으로, 윈도우에서는 필요 없지만 리눅스에서는 추가적인 물리 장치 사용시 마운트를 해주어야 한다.
* 마운트 정보 확인 명령어 : mount
* 기존 마운트 해제 명령어 : umount + ${장치명 또는 디렉토리명}
* 리눅스 기본 명령어
  * ls : List 약자로 디렉터리 내의 파일 목록을 나열한다.
  * pwd : 현재 디렉토리의 절대 경로를 보여준다.
  * cd : 디렉토리 이동. 리눅스에서 상위 디렉토리는 .. 으로 나타내고 현재 디렉토리는 . 으로 나타낸다.
  * rm : 명시된 디렉토리 또는 파일을 삭제한다. (권한이 있을 경우)
  * cp : 파일이나 디렉토리를 복사한다. 새로 복사한 파일은 복사한 사용자의 소유가 된다. cp 명령을 사용할 땐 해당 파일의 읽기 권한이 있어야 한다.
  * touch : 크기가 0인 파일을 생성하거나 파일이 존재할 경우 최종 수정 시간을 현재 시간으로 변경한다.
  * mv : 파일이나 디렉터리의 이름을 변경하거나 다른 디렉터리로 옮길 때 사용한다.
  * mkdir : 디렉토리를 새로 만드는 명령어로 실행한 사용자 소유가 도니다.
  * rmdir : 디렉토리를 삭제하는 명령어로 디렉토리 삭제 권한이 있어야 한다.
  * cat : 파일의 내용을 화면에 보여준다.
  * head : 파일의 앞 N행을 보여준다. e.g. head -3 test.txt
  * tail : 파일의 마지막 N행을 보여준다.
  * more : 텍스트 형식 파일을 페이지 단위로 화면에 출력한다. Space를 누르면 다음 페이지 이동, B를 누르면 앞 페이지 이동, Q를 누르면 종료한다.
  * less : more의 확장 기능으로 화살표, Page up, down 키도 사용할 수 있다.
  * file : 해당 파일이 어떤 종류의 파일인지 표시 해준다.
  * clear : 터미널 화면을 깨끗하게 지워준다.
  * wget : 웹으로부터 
* 사용자 관리  
사용자는 그룹으로 묶일 수 있다. 사용자 정보는 /etc/passwd 파일을 통해 확인할 수 있다. passwd를 보면 각 행이 다음과 같은 형식으로 작성된다.  
**사용자이름:암호:사용자ID:사용자그룹ID:전체이름:홈디렉터리:기본셸**  
예를 들면 다음과 같다.  
centos : x : 1000 : 1000 : centos : /home/centos : /bin/bash  
centos 사용자의 암호는 /etc/shadow 파일에 저장되어 있고(:x 사용자 및 그룹 아이디는 1000 등등을 나타낸다.  
유저를 새로 생성하면 유저의 홈 디렉토리는 /etc/skel 하위 파일들을 복사하여 그대로 생성한다. 따라서 유저의 기본 디렉토리 구조를 변경하고 싶다면 /etc/skel을 변경하면 된다.
* 그룹 관리  
그룹은 /etc/group 파일에서 관리한다. 다음과 같은 형식으로 정의한다.  
**그룹이름:비밀번호:그룹ID:그룹에속한사용자이름**  
* 사용자 및 그룹 관리 명령어
  * useradd : 새로운 사용자를 추가한다.
  * passwd : 사용자의 비밀번호를 지정하거나 변경한다.
  * usermod : 사용자의 속성을 변경한다.
  * userdel : 사용자를 삭제한다.
  * change : 사용자의 암호를 주기적으로 변경하도록 설정한다.
  * groups : 사용자가 소속된 그룹을 보여준다.
  * groupadd : 새로운 그룹을 생성한다.
  * groupmod : 그룹의 속성을 변경한다.
  * groupdel : 그룹을 삭제한다.
* 파일과 디렉터리의 소유와 허가권
리눅스에서 파일의 상세 정보는 아래와 같은 방식으로 보여준다.  
**[파일유형][파일 허가권][링크 수][파일소유자명][파일소유그룹명][파일크기][마지막변경날짜][파일명]**  
  * 파일유형 : 파일의 종류를 포현.
    * 디렉터리 : d
    * 일반파일 : -
    * 블록디바이스(하드디스크, 플로피디스크 등등) : b
    * 문자디바이스(마우스, 키보드, 프린터 등등) : c
    * 링크(윈도우의 바로가기와 비슷한 개념) : l
  * 파일허가권
  파일 허가권은 3자리씩 끊어서 인식하면 된다. rwx로 각각 읽기, 쓰기, 실행 권한을 나타내며 총 9자리로 소유자, 그룹, 그외 사용자 3 분류로 나누어 각각 파일에 대한 허가권을 나타낸다. 3자리를 각각 2진수로 1, 0으로 나타낸 후 10진수로 계산한 값으로 설정 해준다.  
  참고로 디렉터리로 이동하려면 실행 권한이 반드시 있어야 한다.
* 링크  
  * 하드링크 : 파일의 메타 데이터를 공유하는 링크. 즉, 원본 파일의 경로가 옮겨져도 하드링크는 그대로 유지된다.
  * 소프트링크 : 파일의 메타 데이터를 공유 안하고 가리키는 포인터 객체. 즉, 원본 파일의 경로가 옮겨지면 가리키는 경로가 잘못되어 연결이 안된다.
* 리눅스 관리자를 위한 명령어
  * RPM : 초창기 리눅스는 간단한 프로그램 설치도 굉장히 어려웠다. 때문에 윈도우의 setup.exe처럼 쉽게 설치할 수 있는 파일을 제작했는데 이 파일의 확장자가 rpm이며 이를 패키지라고 불렀다.  
  일반적으로 **패키지이름-버전-릴리즈번호.CentOS버전.아키텍처.rpm** 형식으로 이름이 구성된다. 여기서 아키넥처는 x86_64(x86계열의 64비트 CPU를 의미), i386(구형 CPU)와 같은 값을 의미한다.  
  rpm의 가장 큰 단점은 의존성 문제이다. 리눅스에 웹브라우저 FireFox를 설치하고자 할 때 X윈도가 설치 안되어있다면?? 이러한 의존성 관리를 사용자가 전부 해줘야 한다는 점이다.
  * YUM : yum은 rpm의 단점을 극복한 명령어로 특정 패키지를 설치하고자 할 대 의존성이 있는 다른 패키지를 자동으로 먼저 설치해주는 명령어이다. 또한 rpm은 미리 DVD나 인터넷에서 파일을 다운로드 해야하지만 YUM은 rpm 파일 저장소에서 자동 다운로드한 후 설치 해준다.
    * yum install 패키지명 : 패키지를 설치하는 명령어
    * yum check-update : 패키지 중 업데이트 가능한 패키지 목록 출력
    * yum update 패키지명 : 패키지 업데이트. yum install을 사용하면 자동 업데이트 되므로 사용 잘 안함.
    * yum remove 패키지명 : 패키지 삭제.
    * yum info 패키지명 : 패키지 요약 정보를 출력한다.
  * YUM 설정 파일
    * /etc/yum.repos.d : yum 명령어 실행 시 패키지 파일을 검색하는 리포지토리 주소가 들어있는 파일.
    * /etc/yum.conf
  * YUM 작동 방식
    1. yum install을 통해 패키지 설치 명령을 내린다.
    2. /etc/yum.repos.d 디렉토리의 repo 파일을 확인한다. (대표적으로 CentOS-Base.repo) 이 파일에는 패키지 저장소 주소가 적혀있다.
    3. 저장소로 전체 패키지 목록 파일을 요청한다.
    4. 패키지 파일 목록을 응답 받으면 목록을 다운로드 한다.
    5. 설치할 패키지와 관련된 패키지의 이름을 화면에 출력해 설치 여부를 입력 받는다.
    6. 사용자가 Y를 입력하면 설치에 필요한 패키지 파일을 요청한다.
    7. 패키지 파일을 응답받으면 다운로드 후 설치한다.
  * /etc/yum.repos.d 파일의 구성내용
    * 식별자 : repository의 종류를 명시한다. [base]는 기본 저장소, [updates]는 패키지 업데이트에 사용되는 저장소, [extras], [centosplus]를 기타 패키지라고만 이해하자.
    * name : 저장소의 이름을 의미한다.
    * baseurl : 기본 저장소로 http, ftp, file 중 한 가지 프로토콜을 사용한다.
    * mirrorlist : baseurl이 설정 안되어 있으면 mirrorlist중 적절한 저장소를 골라 사용한다.
    * gpgcheck : GPG 서명(rpm 패키지를 인증하는 암호화된 서명)을 확인 할지 여부 설정. 1은 사용, 0은 사용 안함
    * cpgkey : GPG키가 들어있는 저장소 URL
    * enabled : 이 저장소를 사용할지 여부 설정. 1은 사용, 0
* 파일 위치 검색  
리눅스에서 특정 파일의 위치를 검색하는, 가장 많이 사용되는 명령어는 **find**이다.  
  * find /etc -name "*.conf" : /etc 디렉토리 하위에 확장명이 .conf인 파일 검색
  * find /home -user centos : /home 디렉터리 하위에 소유자가 centos인 파일 검색
  * find ~ -perm 644 : 현재 사용자의 홈 디렉터리 하위 허가권이 644인 파일 검색
  * find /usr/bin -size +10k -size -100k : /usr/bin 디렉터리 하위에 파일 크기가 10KB~100KB인 파일 검색
* cron  
주기적으로 반복되는 일을 자동으로 실행할 수 있도록 시스템 작업을 예약해 놓는 것을 cron 이라 부른다. crontab에 주기적으로 작업할 데몬(서비스)을 등록할 수 있다. /etc/crontab 파일에 등록할 수 있으며, 형식은 다음과 같다. **분 시 일 월 요일 사용자 실행명령** 예를 들면, 아래와 같다.  
00 05 1 * * root cp -r /home /backup : 매월 1일 5시에 root 권한으로 /home 디렉토리를 /backup에 복사한다.
* at  
cron과 달리 일회성 작업을 등록할 때 at을 사용한다. 사용 방법은 다음과 같다.  
  1. at 시간 입력
  2. at> 이란 프롬프트가 생기면 예약 명령어 입력 후 엔터 입력
  3. 완료되면 ctrl + D를 눌러 빠져나온다.
  4. at -l 을 눌러 정상적으로 등록 되었는지 확인한다.
  5. atrm 작업번호 를 누르면 등록된 작업이 취소된다.

<br>
<br>

<h4>네트워크 관련 설정과 명령어</h4>

* 명령어
  * systemctl start/stop/restart/status network : 네트워크 설정 변경 후 변경된 내용을 시스템에 적용시키는 명령어.
  * ifup 장치이름 : 해당 장치를 작동시켜 주는 명령어다.
  * ifdown 장치이름 : 해당 네트워크 장치를 끄는 명령어이다.
  * ifconfig 장치이름 : 해당 장치의 IP 주소와 관련된 정보를 출력해주는 명령어.
  * nslookup : DNS 서버의 작동을 테스트하는 명령어
  * ping IP주소 또는 URL : 해당 컴퓨터가 네트워크상에서 응답하는지 테스트하는 명령어.
* 설정파일
  * /etc/sysconfig/network : 네트워크의 기본 정보가 설정되어 있는 파일
  * /etc/sysconfig/network-scripts/ifcfg-ens32 : ens32 장치에 설정된 네트워크 정보가 모두 들어있는 파일
  * /etc/resolv.conf : DNS 서버의 정보와 호스트 이름이 들어있는 파일
  * /etc/hosts : 현 컴퓨터의 호스트 이름과 도메인 이름이 들어있는 파일
* SELinux  
보안에 취약한 리눅스를 보호하기 위하 생긴 기능으로 해커가 어떤 경로로 시스템에 침입하더라도 침입한 경로의 어플리케이션 사용 이상의 권한을 얻지 못하도록 하는 기능이다.

<br>
<br>

<h4>프로세스, 데몬, 서비스</h4>

* 프로세스  
하드디스크에 저장된 실행 코드(프로그램)가, 메모리에 로딩되어 활성화된 것을 의미한다. 프로세스 관련 용어 및 명령어를 몇 가지 알아보자.
  * 포그라운드 프로세스 : Firefox처럼 실행된 프로세스가 화면에 보이는 프로세스를 말한다.
  * 백그라운드 프로세스 : 화면에는 나타나지 않고 뒤에서 실행되는 프로세스를 말한다.
  * 프로세스 번호 : 메모리에 로딩되어 활성화된 프로세스를 구분할 수 있는 고유 번호, ID
  * 작업 번호 : 현재 실행되는 백그라운드 프로세스의 순차 번호
  * 부모 프로세스와 자식 프로세스 : 모든 프로세스는 혼자서 독립적으로 실행되는 것이 아니라 부모 프로세스의 하위에 종속되어 실행된다. 예를 들어 Firefox같은 경우에는 X 윈도 프로세스가 구동된 상태에서 실행되어야 한다. 부모 프로세스가 종료하면 그에 종속된 자식 프로세스도 모두 종료된다.
  * ps : 현재 프로세스의 상태를 확인하는 명령어이다.
  * kill : 프로세스를 강제로 종료하는 명령어이다.
  * pstree : 부모 프로세스와 자식 프로세스의 관계를 트리 형태로 보여준다.
  * CTRL + Z : 현재 실행중인 프로세스를 일시 중지하는 기능으로 SIGSTOP 신호를 프로세스에게 보낸다.
  * CTRL + C : 현재 실행중인 프로세스를 죽이는 기능으로 SIGINT 신호를 보낸다.
  * bg : 현재 실행중인 프로세스를 백그라운드 프로세스로 변경한다.
  * jobs : 백그라운드 프로세스 목록을 작업번호와 함께 볼 수 있다.
  * fg 작업번호 : 백그라운드 프로세스를 포그라운드 프로세스로 변경한다.
* 서비스  
데몬이라고도 부르는 서비스는 서버 프로세스를 말한다. 즉, 서비스는 웹 서버, 네임 서버, DB 서버 등의 프로세스를 지칭한다.

<br>
<br>

<h4>서비스와 소켓</h4>
서비스는 평상시에도 늘 가동되는 서버 프로세스를 의미하고 소켓은 필요할 때만 작동하는 서버 프로세스를 말한다.

* 서비스의 특징
  * 시스템과 독자적으로 구동되어 제공하는 프로세스로 웹 서버, DB 서버, FTP 서버 등이 있다.
  * 실행 및 종료는 대개 'systemctl start/stop/restart 서비스 이름' 으로 사용된다.
  * 서비스의 실행 스크립트 파일은 /usr/lib/systemd/system/ 하위의 '서비스이름.service'라는 이름으로 확인할 수 있다.
  * 부팅과 동시에 서비스의 자동 실행 여부를 지정할 수 있는데 'systemctl list-unit-files'을 실행해 사용함과 안함을 확인할 수 있다.
* 소켓의 특징
  * 소켓은 외부에서 특정 서비스를 요청할 경우에 systemd가 구동 시킨다. 그리고 요청이 끝나면 소켓도 종료된다.
  * 요청이 들어오면 실행 되므로 연결 시간이 서비스에 비해 더 길 수 있다. 대표적인 예로 텔넷 서버가 있다.
  * 소켓과 관련된 스크립트 파일은 /usr/lib/systemd/system 디렉토리에 '소켓이름.socket'이라는 이름으로 존재한다.


<br>
<br>

<h4>간단한 커널 컴파일이란</h4>

커널의 가장 큰 역할은 '하드웨어 지원'이다. 초창기 커널은 지원할 하드웨어가 많지 않았으므로 커널에 하드웨어를 지원하는 코드를 모두 넣어놓았다. 시간이 지날수록 하드웨어가 많아지면서 운영체제가 무거워지는 결과를 낳게된다. 이 문제를 해결하기 위해 자주 사용하지 않고 가끔 사용하는 코드를 별도로 보관했다가 필요할 때 호출하여 사용되는 코드를 모듈이라고 한다.  

<br>
<br>


<h4>리눅스 하드디스크 장치 추가의 개념</h4>

하드디스크 관리하기 설명에 앞서, 간단히 개념 정리를 먼저 해보자.

* IDE : 메인보드에 하드디스크와 같은 장치를 장착할 수 있는 케이블 슬롯을 의미한다. 일반적으로 2개의 IDE가 있고 각 IDE에는 두 개의 케이블을 연결할 수 있다.
* SCSI : 일반 PC에서는 IDE를 사용하지만 서버용 PC에서는 SCSI를 사용한다. SCSI는 슬롯당 최대 16개 장치를 연결할 수 있다.
* 마운트 : 장치를 연결할 때 리눅스는 이전 챕터에서 배웠듯이 디렉토리 마운트를 해줘야 한다.
* 명명규칙 : 일반적으로 하드 디스크를 추가하면 다음과 같이 장치 이름을 명명한다. /dev/sda, /dev/sdb, /dev/sdc... 장치가 추가될 때마다 뒤의 알파벳이 증가한다. 또한 /dev/sda을 파티션 3개로 나눈다면 각 파티션 영역의 이름은 /dev/sda1, /dev/sda2, /dev/sda3가 된다.

<br>
<br>

<h4>리눅스 하드디스크 추가하기</h4>

1. 적절한 SCSI에 새로 구입한 하드디스크를 연결하고 서버를 부팅한다.
2. 하드디스크에 파티션을 할당해야 한다. 예시에선 하나의 파티션을 할당 해본다. 아래 명령어를 순서대로 수행한다.
  * fdisk /dev/sdb ( 새로 추가한 하드디스크 장치 선택 )
  * Command : n ( 새로운 파티션 분할 )
  * Select : p ( Primary 파티션 선택. 파티션의 종류 의미 )
  * First sector 및 Last sector 설정 ( 리눅스에서 한 섹터는 512 바이트이다. 따라서 1GB는 2097152 섹터로 구성된다. 파티션을 하나로 구성할 것이므로 First sector는 1, Last sector는 2097152를 입력하면 된다 )
3. 파일 시스템을 선택한다. 명령어 mkfs.ext4 /dev/sdb1 이라고 입력하면 ext4 라는 파일 시스템을 사용한다는 의미이다. 파일 시스템 설정 단계는 간단히 포맷을 하는 단계라고 생각하자.
4. 디렉토리 마운트 : mount /dev/sdb1 /myspace
5. 서버를 부팅할 때마다 /myspace 디렉토리에 sdb1 장치가 항상 마운트 되어있도록 설정한다.
  * /etc/fstab 파일 ( 리눅스가 부팅될 때 읽는 파일로 마운트 정보가 수록되어 있음 ) 오픈
  * '/dev/sdb1 /myspace ext4 defaults 1 2' 라고 입력한다.
  * 입력 형식은 [장치명][디렉토리][파일시스템][속성][dump사용여부][파일시스템체크여부] 형식으로 입력한다.
6. 파일 저장 후 재부팅을 한다.

<br>
<br>

<h4>RAID란</h4>
여러 개의 하드디스크를 하나의 하드디스크처럼 사용하는 기능으로 두 가지 방식이 있다.

* 하드웨어 RAID : 하드웨어 제조업체에서 여러 개의 하드디스크를 연결한 장비를 만들어서 그 자체를 공급하는 것을 의미한다. 안정적이고 제조업체에서 기술지원을 받을 수 있지만 비교적 비용이 많이 소모되는 방식이다.
* 소프트웨어 RAID : 운영체제에서 지원하는 방식으로 신뢰성이나 속도는 떨어지지만 저렴한 비용으로 구성할 수 있는 방식이다.

<br>
<br>

<h4>RAID 레벨</h4>

* Linear RAID와 RAID0  
최소 두 개의 하드디스크가 필요하다. Linear RAID는 첫 번째 하드디스크가 꽉 찰 때까지 두 번째 하드디스크를 사용 안하지만 RAID0은 두 개의 하드디스크를 골고루 사용한다는 차이점이 있다. 때문에 Linear RAID는 하나의 디스크에 IO가 집중되어 병목이 있지만 RAID0은 입력 시, 병목이 분산되므로 속도가 더 빠르다. 하지만 RAID0은 데이터가 복수 개의 디스크로 분산되므로 하나의 디스크가 망가지면 데이터를 전부 잃게 될 수 있다. 또한 RAID0은 각 디스크가 10GB, 5GB라면 더 작은 용량인 5GB까지만 사용할 수 있다(모든 디스크를 동시에 사용하도록 설계가 되어있기 때문)
* RAID1  
이 방식의 목표는 중요한 데이터의 안전한 저장이다. 때문에 입력된 데이터를 모든 디스크에 중복으로 저장하여 하나의 하드 디스크가 고장 나더라도 데이터가 보존됨을 보장한다.
* RAID5  
위의 두개 방식의 장점을 합쳐놓은 방식으로 최소 3개 이상의 하드디스크가 있어야 구성이 가능하다(일반적으로 하드디스크 5개 사용). 하드디스크에 오류가 발생하면 패리티 비트를 이용해서 데이터 복구가 가능하다. 자세한 사항은 다음 장에서 보자.


<br>
<br>

<h4>RAID5</h4>
예를 들어 '000 111 010 011'이라는 12비트 데이터를 4개 하드디스크로 구성된 RAID5에 저장한다고 해보자. 아래 그림처럼 각 데이터가 하드디스크 4개에 나누어서 작성되게 된다. 그림에서 빨간색 데이터는 패리티 비트를 의미하게 된다. 아래의 경우 짝수 패리티 방식을 사용한 것이다. 각 하드디스크의 동일한 행엔 1의 갯수가 짝수가 되도록 데이터를 작성하는 것이다. 이렇게 하면 하나의 디스크가 고장 나더라도 나머지 데이터를 통해 데이터를 복구할 수 있다.  
  
  
![LinuxRaid5](images/linux/RAID5.png?raw=true "LinuxRaid5")


<br>
<br>

<h4>LVM</h4>
Logical Volume Manager의 약자로 논리 하드디스크 관리자라고 할 수 있다. 기본적으로 기본 기능은 Linear RAID와 비슷하지만 더 다양한 기능을 가지고 있다. 때문에 CentOS 기본 설치 시엔 LVM으로 하드디스크를 분할해서 설치한다. LVM은 아래와 같은 새로운 용어가 있다. 숙지하자.

* 물리볼륨 : /dev/sda1, /dev/sdb1 등의 파티션을 의미한다.
* 볼륨그룹 : 물리볼륨을 합쳐서 1개의 물리 그룹으로 만들 수 있다.
* 논리볼륨 : 볼륨그룹을 1개 이상으로 나눈 것으로 논리적 그룹이라고도 한다.

위의 용어를 통해 LVM은 여러 개의 하드디스크(물리볼륨)를 묶어서 1개의 볼륨 그룹으로 만든 후 다시 필요한 용량의 파티션(논리그룹)으로 나누어 사용하는 기능으로 보면 된다. 일반적으로 서버 리부팅 없이 동적으로 파티션을 나누기 위해 사용한다

<br>
<br>

<h4></h4>

<br>
<br>

<h4></h4>

<br>
<br>

<h4></h4>

<br>
<br>

<h4></h4>

<br>
<br>

<h4></h4>

<br>
<br>

<h4></h4>

<br>
<br>

<h4></h4>

<br>
<br>

