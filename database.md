<h3>데이터베이스 내용 정리</h3>


<h4>정규화와 비정규화</h4>
정규화는 데이터의 중복을 최소화 하기 위해 테이블을 나누는 설계를 의미한다. 필요한 데이터 조회를 위해 join을 해야 하므로 조회 시 성능이 떨어지게 된다.
반면 비정규화는 조회 성능을 올릴 수 있도록 설계하는 방식을 의미한다.

<br><br>

<h4>Join</h4>

* 내부조인 : 조건에 부합되는 데이터만 결과 집합에 포함되는 조인
* 외부조인
  + 좌측 외부 조인 : 왼쪽 테이블은 모든 데이터가 포함되고 오른쪽 테이블 중 조건에 안맞는 데이터는 null로 채워진다.
  + 우측 외부 조인 : 오른쪽 테이블에 대하여 좌측 외부 조인과 같은 특성 적용
  + 완전 외부 조인 : 왼쪽 오른쪽 모두 모든 데이터가 집합에 포함된다.

<br><br>

<h4>ACID</h4>  

* 원자성(Atomicity)
트랜잭션과 관련된 작업들이 부분적으로 실행되다가 중단되지 않는 것을 보장하는 능력이다.
예를 들어, 자금 이체는 성공할 수도 실패할 수도 있지만 보내는 쪽에서 돈을 빼 오는 작업만 성공하고 받는 쪽에 돈을 넣는 작업을 실패해서는 안된다.
원자성은 이와 같이 중간 단계까지 실행되고 실패하는 일이 없도록 하는 것이다.

* 일관성(Consistency)
트랜잭션이 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 유지하는 것을 의미한다.
무결성 제약이 모든 계좌는 잔고가 있어야 한다면 이를 위반하는 트랜잭션은 중단된다.

* 고립성(Isolation) 
트랜잭션을 수행 시 다른 트랜잭션의 연산 작업이 끼어들지 못하도록 보장하는 것을 의미한다.
이것은 트랜잭션 밖에 있는 어떤 연산도 중간 단계의 데이터를 볼 수 없음을 의미한다.
은행 관리자는 이체 작업을 하는 도중에 쿼리를 실행하더라도 특정 계좌간 이체하는 양 쪽을 볼 수 없다.
공식적으로 고립성은 트랜잭션 실행내역은 연속적이어야 함을 의미한다. 성능관련 이유로 인해 이 특성은 가장 유연성 있는 제약 조건이다.

* 지속성(Durability)
성공적으로 수행된 트랜잭션은 영원히 반영되어야 함을 의미한다. 시스템 문제, DB 일관성 체크 등을 하더라도 유지되어야 함을 의미한다.
전형적으로 모든 트랜잭션은 로그로 남고 시스템 장애 발생 전 상태로 되돌릴 수 있다.
트랜잭션은 로그에 모든 것이 저장된 후에만 commit 상태로 간주될 수 있다.
<br><br>

<h4>Isolation level</h4>
트랜잭션 실행 중 중간 연산 결과가 다른 트랜잭션으로 접근 불가하도록 하는 고립성을 유지하기 위한 데이터를 허용하는 수준  

1. 병행제어 미처리 시 발생하는 문제 유형
      * 부정판독(dirty read) : commit 되지 않은 데이터를 읽을 수 있음. 데이터를 읽었는데 만약 해당 데이터가 rollback 되면 없는 데이터를 처리하는 결과가 된다.
      * 비반복판독(Nonrepeatable read) : commit된 데이터만 읽음. 한 트랜잭션에서 같은 조건의 row를 두번 읽는데 그 사이 그 row가 수정/삭제되면 쿼리 결과가 달라짐.
      * 가상판독(phantom read) : 특정 조건의 복수개 row를 두번 조회하는데 그 사이 다른 트랜잭션이 insert를 하여 값이 다르게 조회되는 현상
2. isolation level  
      * Read uncommited : commit이 안된 데이터도 읽을 수 있음. shared lock이 없는 level. diry read, Nonrepeatable read, phantom read 모두 발생할 수 있음.
      * Read commited : commit된 데이터만 읽을 수 있음. DBMS별로 shared lock이 걸릴수도 아닐수도 있다. Nonrepeatable read, phantom read가 발생할 수 있음.
      * Repeatable read : 선행 트랜잭션이 읽은 row를 후행 트랜잭션이 수정/삭제 못하도록 shared lock을 걸음. Phantom read가 발생할 수 있음.
      * Serializable : 선행 트랜잭션이 읽은 데이터를 수정/삭제도 못하고 중간에 새로운 레코드를 추가할 수도 없도록 함. Repeatable read 수준에서 범위에 대한 shared lock을 걸음. 직렬성 위반 발생 불가.
3. 주의점  
isolation level이 높다고 무조건 좋은것이 아님. isolation level이 높으면 그만큼 성능이 떨어짐.

<br><br>

<h4></h4>

<br><br>

<h4></h4>

<br><br>

<h4></h4>

<br><br>

<h4></h4>

<br><br>

<h4></h4>

<br><br>

<h4></h4>

<br><br>

<h4></h4>

<br><br>

<h4></h4>

<br><br>

<h4></h4>

<br><br>

<h4></h4>

<br><br>

<h4></h4>

<br><br>

<h4></h4>

<br><br>

<h4></h4>

<br><br>

