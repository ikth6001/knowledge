<h3>Network 내용 정리</h3>



<h4>웹 브라우저가 메시지를 만든다(웹 브라우저의 내부 탐험)</h4>

* 웹 브라우저 

1. Http 리퀘스트 메시지 작성 : 사용자가 웹 브라우저에 URL을 입력하면 브라우저는 URL에 따라 리퀘스트 메시지를 만든다.
2. 웹 서버의 IP 주소를 DNS 서버에서 조회 : 메시지를 다 만든 웹 브라우저는 OS에 의뢰해 메시지를 웹 서버에 송신하는데 이때 메시지를 넘기는 대상 서버의 IP 주소를 OS에 통지해야 한다. URL 안에는 웹 서버의 도메인명이 쓰여있으므로 DNS 서버를 통해 해당 IP 주소를 조사한다.
3. IP주소 조회 요청을 받은 DNS는 전 세계의 DNS 서버와 연대하여 IP 주소를 검색하여 응답한다.
4. 프로토콜 스택에 메시지 송신 의뢰 : IP 주소를 DNS 서버로부터 응답 받으면 OS에 메시지 전송을 의뢰 하는데, 이 의뢰하는 방법도 규약이 있고 이를 프로토콜 스택이라고 한다.

* Http 요청 메시지를 작성한다.

1. 통신은URL 입력부터 시작한다.  
사용자가 브라우저에 입력하는 URL은 ${Protocol}: 포맷으로 시작한다. 브라우저는 http 프로토콜 외에 ftp, mailto와 같은 다양한 프로토콜을 지원한다(프로토콜은 통신하는 필요한 약속된 절차) http는 웹서버와 통신하는 규약이라고 생각하면 된다. 
2. 브라우저는 먼저 URL을 해독한다.  
일반적인 http 프로토콜 URL은 다음과 같이 해석될 수 있다. http://www.mysite.co.kr/secret/member.html 을 예로 들면, http 프로토콜을 사용하고 www.mysite.co.kr 이라는 도메인 이름을 가진 웹 서버에 /secret/member.html 이라는 파일을 요청한다(이 파일 부분을 일반적으로 URI라고 한다).  
3. http 요청 메시지를 만든다.  
http 프로토콜을 활용해 요청 메시지를 보낼 땐 '무엇을', '어떻게' 하라는 의미가 들어있다. 먼저 '무엇을'에 해당하는 것이 URI이다. 다음으로 '어떻게'에 해당하는 부분이 http의 메소드 개념이다. http에는 GET, POST, PUT, DELETE 등등 다양한 메소드가 존재한다.  
4. 요청 메시지를 보내면 응답이 되돌아온다.  
브라우저는 응답 데이터에 image 또는 영상을 나타내는 태그 해당 부분을 비워둔 후 응답 데이터를 페이지로 만든다. 그리고 해당 태그에 해당하는 데이터를 다시 웹 서버에 요청한다. http 프로토콜은 한 번 요청에 하나의 데이터를 가져올 수 있으므로 만약 응답 페이지에 3개의 이미지가 있다면 총 4번의 요청을 보내게 된다.  

* 웹 서버의 IP주소를 DNS서버에 조회한다.  

1. IP주소의 구성
서브넷(PC와 같은 여러대의 네트워크 접속 장비들을 허브로 연결한 후 라우터에 연결한 하나의 묶음)의 집합인 네트워크에서 요청할 서버를 찾는데 사용되는 키 값이 IP주소이다. IP주소는 네트워크 번호와 호스트 번호로 나뉜다. 네트워크 번호를 통해 서브넷을 찾고, 나머지 호스트 번호를 통해 서브넷에서 네트워크 접속 장비를 찾는다. 예를 들어, 192.168.100.120/24 라고 한다면, 24bit인 192.168.100은 네트워크 번호이고 마지막 120번은 호스트 번호가 된다.  
2. Socket 라이브러리를 이용하여 DNS에 요청을 보내 IP 주소를 찾는다.  

* 전 세계의 DNS 서버가 연대한다  
수 많은 웹 서버의 정보를 하나의 DNS 서버에 등록하는 것은 불가능하기에 다수의 DNS 서버가 정보를 분산/등록하고 연대하는 구조이다. 일반적인 know.co.kr 과 같은 URL은 도메인 구조를 가지고 있다. kr(한국)이라는 도메인 하위에 co(회사)라는 도메인 그리고 그 하위에 know라는 도메인이 있는 것이다. 이 도메인 구조를 통해 모든 DNS 서버를 조회 안하고 효과적으로 IP를 찾을 수 있다. 하위 도메인을 담당하는 DNS 서버의 IP 주소를 상위 도메인을 관리하는 DNS 서버에 등록을 하여 IP 주소 조회 시, 상위 도메인의 DNS부터 차례로 내려가며 검색할 수 있다. 추가로 모든 DNS 서버는 최상위 도메인 DNS 서버(루트 DNS)의 IP 주소를 등록하여 어느 DNS를 통해서도 루트 DNS로 향할 수 있도록 한다.  

* 프로토콜 스택에 메시지 송신을 의뢰한다  
IP주소를 DNS로부터 알아냈으면 웹 서버에 메시지를 송신하도록 OS의 내부에 있는 프로토콜 스택에 송신을 의뢰한다. 마찬가지로 OS에 송신을 의뢰하기 위해선 Socket 라이브러리를 활용한다. 과정은 **'소켓 생성 > 서버의 생성된 소켓에 파이프 연결 > 데이터 송수신 > 파이프 분리 및 소켓 말소'** 이다. 







<br>
<br>
<h4>TCP/IP의 데이터를 전기 신호로 만들어 보낸다(프로토콜 스택과 LAN 어댑터의 탐험)</h4>  

* 프로토콜 스택  

OS에 내장된 네트워크 제어용 소프트웨어를 프로토콜 스택이라고 한다. 프로토콜 스택과 네트워크용 하드웨어(LAN 어댑터)가 어플리케이션에게 받은 메시지를 서버에 송출하는 동작을 하게 된다.  
프로토콜 스택을 포함한 구조를 간략히 이미지로 나타내면 아래와 같다.  
![protocolStack](images/network/protocolStack.PNG?raw=true "protocolStack")

1. 소켓을 작성한다 : 애플리케이션의 의뢰를 받은 프로토콜 스택이 TCP 프로토콜을 이용하여 메시지를 송신하는 동작은 4단계로 요약할 수 있는데 그 첫 단계가 소켓을 생성하는 것이다. (TCP 프로토콜은 오류 때문에 패킷이 없어졌을 때 다시 보내거나 하는 편의 기능이 많다. 그 외 다른 특징을 가진 UDP 프로토콜도 있다)
2. 서버에 접속한다 : 클라이언트측의 소켓을 서버측의 소켓에 접속하는 단계이다.
3. 데이터를 송/수신한다 : 프로토콜 스택은 애플리케이션에게 의뢰받은 메시지를 작은 조각(패킷)으로 분할하여 서버를 향해 송신한다. TCP 프로토콜 메시지 송/수신 동작의 다음은 실제 패킷을 보내는 것으로 프로토콜 스택과 LAN 어댑터가 연대하여 패킷을 전기나 빛의 신호로 변환하여 케이블에 송출한다.
4. 서버에서 연결을 끊어 소켓을 말소한다.  

* 소켓을 작성한다  
소켓이란 논리적인 객체이다. 즉 실제 물리적인 어떤 것이 생성되는 것이 아니고 통신에 필요한 다양한 메타 정보를 메모리에 저장하고 이를 소켓이라고 부르는 것이다.  

* 서버에 접속한다  
접속은 서버와 통신할 수 있는 상태가 되는 것이다. 클라이언트의 소켓이 생성되면 소켓 안의 정보로는 통신을 할 수 없다. 브라우저와 같은 어플리케이션은 대상 서버의 URL, 포트와 같은 정보를 가지고 있지만 지금 막 만든 소켓엔 해당 정보가 없다. 마찬가지로 서버측의 소켓도 통신할 클라이언트의 정보를 가지고 있지 않다. 때문에 접속의 첫 번째 동작은 통신 상대와 제어정보룰 주고받아 소켓에 필요한 정보를 기록하여 데이터 송/수신이 가능한 상태로 만드는 것이다.  

* 데이터를 송/수신한다  
어플리케이션이 데이터 송신을 요청하면 프로토콜 스택은 일단 해당 데이터를 내부 버퍼 메모리에 저장한 후 일정 크기가 되면 송신하게 된다. 이 일정 크기는 하나 패킷의 크기와 네트워크 상태에 따라 결정된다. 또한 만약 TCP 프로토콜을 사용한다면 송신한 패킷이 올바르게 서버에 도착했는지 확인하고 도착 안했다면 재전송하는 기능이 있습니다. 전송이 정상적으로 되었음이 확인되면 버퍼 메모리를 비우게 된다. 이를 위해 서버는 패킷을 수신하면 수신을 했다는 응답을 보내게 된다. 이 때 양측은 시퀀스 번호와 ACK 번호를 통해 각 패킷의 전송이 잘 되었는지 여부를 확인하게 된다.  
초기 통신에선 클라이언트가 하나의 패킷을 보내고 정상 수신 응답을 받으면 다음 패킷을 보내는 방식이었기에 통신의 지연이 많았다. 이 문제 개선을 위해 클라이언트는 서버측에 패킷 정상 수신 응답을 기다리지 않고 서버의 수용 가능한 수신 버퍼 크기만큼(통신 시 서버로부터 받는 정보) 바로바로 보내도록 변경이 되었다. 이를 윈도우 제어 방식이라고 한다.  
송신이 끝나면 프로토콜 스택은 응답 데이터를 수신하기 위해 read 상태로 가게 된다. 데이터를 수신하면 데이터가 누락되었는지 검사하고 문제가 없으면 수신이 완료 되었다는 응답을 보내게 된다. 패킷 조각이 하나의 데이터로 완성이 되면 어플리케이션에 전달하게 된다.  

* 서버에서 연결을 끊어 소켓을 말소한다  
서버와 클라이언트 중 어느 쪽에서 close를 먼저 시작하는지는 개발한 어플리케이션/서버에 따라 다르다. 프로토콜 스택은 어느쪽이 먼저 시작하든 상관 없도록 개발되어 있다. 서버라고 가정을 하자면, 서버가 close 하자는 내용의 메시지를 클라이언트에 보내면 클라이언트는 이를 수신 후 서버엔 정상 수신 응답을 보낸다. 이 후 만약 어플리케이션에서 read요청을 보내면 read가 완료 되었다는 응답을 보내고, 그럼 어플리케이션도 close를 시도하게 된다. 그럼 프로토콜 스택(TCP)은 서버에 이 사실을 메시지 보내고, 서버도 정상 수신 응답을 보내면서 소켓이 말소하게 된다.  

* IP와 이더넷의 패킷 송/수신 동작  
프로토콜 스택의 TCP(또는 UDP) 부분은 패킷에 TCP 헤더를 붙인 후, IP부분에 전송을 의뢰한다. IP부분은 받은 패킷에 IP 헤더(IP프로토콜에 규정된 규칙에 따라 IP주소로 목적지까지 패킷 전달에 사용하는 제어정보)와 MAC 헤더(이더넷 등 LAN을 사용해 가장 가까운 라우터까지 패킷을 전달하는데 사용하는 제어정보)를 만든 다.  
MAC 헤더엔 송신/수신처 MAC 주소가 포함되어야 한다. 송신처의 MAC주소는 LAN 어댑터에 작성되어 있기 때문에 해당 주소를 작성하면 되지만 수신처 MAC주소는 ARP라는 프로토콜을 활용해서 알아내야 한다. ARP는 같은 **이더넷** 환경에 있는 모든 노드에게 브로드캐스트로 이 IP에 해당하는 노드가 있는지 묻는 요청ㅇ르 보내고 해당 노드는 자신의 MAC 주소를 응답하는 방식이다(물론 캐쉬를 활용할 수 있다)  
이후, 네트워크용 하드웨어(LAN 어댑터)에 전달한다. 이 후 디지털 데이터(0이나 1로 구성된 데이터)가 전기나 빛 신호 상태로 변경되어 케이블에 송출되게 된다. 신호는 허브나 라우터와 같은 중계 장치로 가게 되고 이 중계 장치에서 목적지를 향하는 다음 중계 장치로 전달되게 된다.  

* UDP 프로토콜을 이용한 송/수신 동작  
TCP는 데이터를 확실하게 전달하기 위해 사용하는 프로토콜이다. 이를 위해 송신 후 수신측에 수신 확인 응답을 받고, 만약 도착 안 한 경우 재송신을 하게된다.  UDP에는 TCP와 같은 수신 확인이나 윈도우가 없어서 데이터 송/수신 전에 정보를 주고받을 필요가 없고 접속이나 연결 끊기 단계도 없다. 간단하게 패킷 송신 후 오류 확인을 안하고, 응답이 없다면 다시 보내는 방식을 사용한다. 음성이나 동영상같이 데이터 전송 속도가 빠른 경우에 일반적으로 사용한다. 또한 데이터의 일부분이 오류가 나더라도 사용자 입장에서 크게 불편함을 느낄일도 없다.

<br>
<br>
<h4>케이블의 앞은 LAN기기였다(허브와 스위치, 라우터의 탐험)</h4>  

* 케이블과 리피터, 허브 속을 신호가 흘러간다.  
LAN 어댑터의 신호가 리피터 허브에 도달하면 리피터 허브는 연결된 모든 노드로 신호를 송출한다. 리피터 허브는 단순히 송출을 목적으로 하기 때문에 신호의 정합성을 검사하지는 않는다. 리피터 허브로부터 신호를 받은 서버, 스위칭 허브, 라우터와 같은 노드들은 수신처 MAC 주소에 해당하는 기기만 패킷을 수신하게 된다.  

* 스위칭 허브의 패킷 중계 동작  
스위칭 허브는 리피터 허브에게 받은 신호를 디지털 신호로 변경한 후 메모리 버퍼에 쌓아 놓는다. 이 후 MAC 주소를 통해 어디로 전송해야 하는지 확인 후 해당 포트(전송하는 곳)으로 패킷을 보내면 송신 동작(송신중인 신호가 있는지 확인하고 없다면 패킷을 신호로 변경 후 송출)이 실행되어 케이블에 신호가 흘러가게 된다. 만약 송신할 목적지를 못 찾는 경우(MAC 주소 테이블에 없는 경우)에는 모든 송출지에 신호를 보내면 된다(이더넷 프로토콜)  

* 라우터의 패킷 중계 동작  
이더넷을 바탕으로 하는 허브의 중계 동작과 달리 라우터는 IP를 바탕으로 패킷을 전송하기 때문에 패킷 전송 방법에 있어 차이가 있다. 라우터의 내부 구조는 중계 부분과 포트 부분으로 나뉜다. 중계 부분은 패킷의 중계 대상을 판단하는 동작을 하고 포트 부분은 패킷을 송/수신하는 동작을 한다. 라우터의 포트 부분은 이더넷, 무선 LAN 통신 방식만 가능한 PC의 LAN 어댑터와 다르게 ADSL, 전용 회선 등등 다양한 통신 기술을 사용할 수 있다.  
중계 부분에선 IP를 통해 다음 목적지를 파악한다. 라우터 경로표엔 IP주소 목록이 있고 이 목록과 수신처 IP의 네트워크 부분만을 비교하여 일치하는 항목을 찾게된다. 라우터는 허브와 다르게 송신 작업을 하면서 라우터 경로표를 갱신하지 않고 사람이 수동으로 등록/갱신 하거나 라우팅 프로토콜(RIP, OSPF, BGP)을 통해 라우터끼리 경로 정보를 교환하며 경로표를 등록한다. 또한 만약 경로표에서 일치하는 항목을 못 찾은 경우엔 ICMP 메시지로 송신처에 이 사실을 통지하게 되어있다. 이더넷 환경에서 사용하는 허브는 많아야 노드 수가 몇 천개이기 때문에 전체 송신을 해도 문제가 없지만 인터넷 환경 기반의 라우터는 이렇게 처리할 수가 없다.  
또한 라우터의 패킷은 TTL이라는 생존기간이 있어 라우터를 지날 때마다 이 값을 1씩 감소시키고 0이 되면 패킷을 폐기한다. 라우터 경로표에 오류가 있거나 제대로 갱신이 안되어 패킷이 네트워크 상에 무한대로 떠돌아다니는 것을 방지하기 위한 값이다. 또한 라우터는 다양한 통신회선을 사용할 수 있고 통신회선 마다 허용하는 패킷의 크기가 다르므로 큰 패킷인 경우 조각 나누기를 통해 분할해야 한다.  

* 라우터의 부가 기능  
1. 주소변환 : 부족한 IP 대역 문제를 해결하기 위해 사설 LAN에서는 내부 IP를 사용하고 인터넷에 접속할 수 있는 게이트웨이와 같은 존재가 있다. 사설 LAN에 접속한 PC가 인터넷의 한 웹서버에 접속을 시도하면 게이트웨이가 자신에게 부여된 외부 IP + 임의 부여한 포트 번호와 해당 PC의 내부 IP를 매핑한 정보를 가지고, IP 헤더의 송신 IP를 외부 IP로 변경한 후 패킷을 전송하고 응답이 오면 매핑된 정보를 통해 내부 PC에게 전달한다.  
2. 인터넷에서 회사로 엑세스 : 위와 같이 사설 LAN을 사용하면 외부 인터넷 환경에서 내부 PC로의 접속이 불가능하므로 보안효과가 있다.





<br>
<br>
<h4>엑세스 회선을 통해 인터넷의 내부로(엑세스 회선과 프로바이더의 탐험)</h4>  

인터넷의 실체는 한 개의 조직이 운영 관리하는 단일 네트워크가 아니라 다수의 프로바이더의 네트워크를 서로 접속한 것이다. 그리고 ADSL이나 광섬유의 엑세스 회선은 사용자가 계약한 프로바이더의 설비에 연결되어 있는데 이 설비를 POP라고 한다.  

* 프로바이더를 경유하여 흐르는 패킷  
서버의 프로바이더와 클라이언트의 프로바이더가 같고 다르고가 패킷의 경유에 영향을 미치지 않는다. POP에 도착하면 POP도 라우터이고, 다른 라우터와 통신하며 중계 대상 정보를 업데이트 하므로 다음 라우터에게 패킷을 전송하게 된다. 라우터간 중계 정보 교환은 단순히 통신을 하는 것이다. A라우터가 자신이 관리하는 서브넷 IP주소를 B라우터에게 전송하면 B라우터도 자신의 정보를 응답한다. 또한 교환 방식에 따라 A라우터에게 정보를 받은 B라우터는 A라우터의 정보를 다른 연결된 라우터들에게 전파할 수도 있다. 단! 서로 다른 프로바이더의 라우터 간의 정보 교환은 서로 비용 관련 계약이 이루어져 있을 때만 한다.  
그렇다면 프로바이더 간의 연결은 프로바이더끼리 회선을 연결할까?? 그렇게 할 경우엔 수 많은 회선이 필요하게 된다. 때문에 중간에 IX라는 프로바이더 회선의 경유지를 놓고 이 IX를 통해 다른 프로바이더에 접속하게 된다.



<br>
<br>
<h4>서버측의 LAN에는 무엇이 있는가?(방화벽과 캐시 서버의 탐험)</h4>  

* 웹 서버의 설치 장소  
웹 서버를 일반적으로 사내에 설치할 경우엔 방화벽을 웹 서버 앞에 위치시킨 후에 설치한다. 보안 문제를 해결하기 위해서다. 또 다른 방법으로 사내 설치가 아닌 데이터센터와 같은 시설에 서버를 설치하는 방법도 있다. 데이터센터는 프로바이더의 중심 부분에 있는 NOC에 직접 접속되었거나 IX에 직결되어 있기 때문에 고속 엑세스 할 수 있다는 장점이 있다. 그 외에도 방화벽, 내진 구조 건물과 같은 장점이 있다.  

* 방화벽의 원리와 동작  
방화벽의 기본 개념은 특정 서버와 해당 서버 안의 특정 애플리케이션에 액세스하는 패킷만 통과시키고 그외 패킷은 차단하는 것이다. 일반적으로 패킷 필터링 방법을 사용 하는데 패킷의 헤더에 있는 다양한 제어 정보를 통해 패킷 필터링 여부를 파악한다.  

* 복수 서버에 리퀘스트를 분배한 서버의 부하 분산  
서버에 접속이 많아지만 해결하기 위한 방법 중 하나는 분산처리이다. 여러 대의 웹 서버를 설치하고 한 대가 담당하는 사용자 수를 줄이는 것이다.  구체적인 방법 중 하나로 DNS 서버에서 분배하는 방법이다. DNS 서버에 같은 이름으로 여러 대의 웹 서버를 등록해 놓으면 된다. 하지만 웹 서버가 특정 이유로 shutdown 되는 경우 DNS 서버는 이 사실을 알 수 없다는 단점이 있다. 이런 단점을 피하기 위해 DNS를 대신할 부하 분산 장치가 고안되었다. 웹 서버 대신 DNS 서버에 부하 분산 장치를 등록하면 클라이언트는 부하 분산 장치에 요청을 보내게 되고 부하분산 장치는 주기적으로 웹 서버와 통신하며 CPU, 메모리 사용률 등을 파악하고 이 정보를 근거로 적절한 웹서버에게 요청을 위임하게 된다.  

* 캐시 서버를 이용한 서버의 부하분산



<br>
<br>
<h4></h4>

<br>
<br>
<h4></h4>

<br>
<br>
<h4></h4>

<br>
<br>
<h4></h4>

<br>
<br>
<h4></h4>

<br>
<br>
<h4></h4>

<br>
<br>
<h4></h4>

<br>
<br>
<h4></h4>

<br>
<br>
<h4></h4>

<br>
<br>
<h4></h4>

<br>
<br>
<h4></h4>

<br>
<br>
<h4></h4>

<br>
<br>
<h4></h4>

<br>
<br>
<h4></h4>

<br>
<br>
<h4></h4>

<br>
<br>
<h4></h4>

<br>
<br>
<h4></h4>

<br>
<br>
<h4></h4>

<br>
<br>
<h4></h4>

