<h3>Network 내용 정리</h3>



<h4>웹 브라우저가 메시지를 만든다(웹 브라우저의 내부 탐험)</h4>

* 웹 브라우저 

1. Http 리퀘스트 메시지 작성 : 사용자가 웹 브라우저에 URL을 입력하면 브라우저는 URL에 따라 리퀘스트 메시지를 만든다.
2. 웹 서버의 IP 주소를 DNS 서버에서 조회 : 메시지를 다 만든 웹 브라우저는 OS에 의뢰해 메시지를 웹 서버에 송신하는데 이때 메시지를 넘기는 대상 서버의 IP 주소를 OS에 통지해야 한다. URL 안에는 웹 서버의 도메인명이 쓰여있으므로 DNS 서버를 통해 해당 IP 주소를 조사한다.
3. IP주소 조회 요청을 받은 DNS는 전 세계의 DNS 서버와 연대하여 IP 주소를 검색하여 응답한다.
4. 프로토콜 스택에 메시지 송신 의뢰 : IP 주소를 DNS 서버로부터 응답 받으면 OS에 메시지 전송을 의뢰 하는데, 이 의뢰하는 방법도 규약이 있고 이를 프로토콜 스택이라고 한다.

* Http 요청 메시지를 작성한다.

1. 통신은URL 입력부터 시작한다.  
사용자가 브라우저에 입력하는 URL은 ${Protocol}: 포맷으로 시작한다. 브라우저는 http 프로토콜 외에 ftp, mailto와 같은 다양한 프로토콜을 지원한다(프로토콜은 통신하는 필요한 약속된 절차) http는 웹서버와 통신하는 규약이라고 생각하면 된다. 
2. 브라우저는 먼저 URL을 해독한다.  
일반적인 http 프로토콜 URL은 다음과 같이 해석될 수 있다. http://www.mysite.co.kr/secret/member.html 을 예로 들면, http 프로토콜을 사용하고 www.mysite.co.kr 이라는 도메인 이름을 가진 웹 서버에 /secret/member.html 이라는 파일을 요청한다(이 파일 부분을 일반적으로 URI라고 한다).  
3. http 요청 메시지를 만든다.  
http 프로토콜을 활용해 요청 메시지를 보낼 땐 '무엇을', '어떻게' 하라는 의미가 들어있다. 먼저 '무엇을'에 해당하는 것이 URI이다. 다음으로 '어떻게'에 해당하는 부분이 http의 메소드 개념이다. http에는 GET, POST, PUT, DELETE 등등 다양한 메소드가 존재한다.  
4. 요청 메시지를 보내면 응답이 되돌아온다.  
브라우저는 응답 데이터에 image 또는 영상을 나타내는 태그 해당 부분을 비워둔 후 응답 데이터를 페이지로 만든다. 그리고 해당 태그에 해당하는 데이터를 다시 웹 서버에 요청한다. http 프로토콜은 한 번 요청에 하나의 데이터를 가져올 수 있으므로 만약 응답 페이지에 3개의 이미지가 있다면 총 4번의 요청을 보내게 된다.  

* 웹 서버의 IP주소를 DNS서버에 조회한다.  

1. IP주소의 구성
서브넷(PC와 같은 여러대의 네트워크 접속 장비들을 허브로 연결한 후 라우터에 연결한 하나의 묶음)의 집합인 네트워크에서 요청할 서버를 찾는데 사용되는 키 값이 IP주소이다. IP주소는 네트워크 번호와 호스트 번호로 나뉜다. 네트워크 번호를 통해 서브넷을 찾고, 나머지 호스트 번호를 통해 서브넷에서 네트워크 접속 장비를 찾는다. 예를 들어, 192.168.100.120/24 라고 한다면, 24bit인 192.168.100은 네트워크 번호이고 마지막 120번은 호스트 번호가 된다.  
2. Socket 라이브러리를 이용하여 DNS에 요청을 보내 IP 주소를 찾는다.  

* 전 세계의 DNS 서버가 연대한다  
수 많은 웹 서버의 정보를 하나의 DNS 서버에 등록하는 것은 불가능하기에 다수의 DNS 서버가 정보를 분산/등록하고 연대하는 구조이다. 일반적인 know.co.kr 과 같은 URL은 도메인 구조를 가지고 있다. kr(한국)이라는 도메인 하위에 co(회사)라는 도메인 그리고 그 하위에 know라는 도메인이 있는 것이다. 이 도메인 구조를 통해 모든 DNS 서버를 조회 안하고 효과적으로 IP를 찾을 수 있다. 하위 도메인을 담당하는 DNS 서버의 IP 주소를 상위 도메인을 관리하는 DNS 서버에 등록을 하여 IP 주소 조회 시, 상위 도메인의 DNS부터 차례로 내려가며 검색할 수 있다. 추가로 모든 DNS 서버는 최상위 도메인 DNS 서버(루트 DNS)의 IP 주소를 등록하여 어느 DNS를 통해서도 루트 DNS로 향할 수 있도록 한다.  

* 프로토콜 스택에 메시지 송신을 의뢰한다  
IP주소를 DNS로부터 알아냈으면 웹 서버에 메시지를 송신하도록 OS의 내부에 있는 프로토콜 스택에 송신을 의뢰한다. 마찬가지로 OS에 송신을 의뢰하기 위해선 Socket 라이브러리를 활용한다. 과정은 **'소켓 생성 > 서버의 생성된 소켓에 파이프 연결 > 데이터 송수신 > 파이프 분리 및 소켓 말소'** 이다. 







<br>
<br>
<h4>TCP/IP의 데이터를 전기 신호로 만들어 보낸다(프로토콜 스택과 LAN 어댑터의 탐험)</h4>  

* 프로토콜 스택  

OS에 내장된 네트워크 제어용 소프트웨어를 프로토콜 스택이라고 한다. 프로토콜 스택과 네트워크용 하드웨어(LAN 어댑터)가 어플리케이션에게 받은 메시지를 서버에 송출하는 동작을 하게 된다.  
프로토콜 스택을 포함한 구조를 간략히 이미지로 나타내면 아래와 같다.  
![protocolStack](images/network/protocolStack.PNG?raw=true "protocolStack")

1. 소켓을 작성한다 : 애플리케이션의 의뢰를 받은 프로토콜 스택이 TCP 프로토콜을 이용하여 메시지를 송신하는 동작은 4단계로 요약할 수 있는데 그 첫 단계가 소켓을 생성하는 것이다. (TCP 프로토콜은 오류 때문에 패킷이 없어졌을 때 다시 보내거나 하는 편의 기능이 많다. 그 외 다른 특징을 가진 UDP 프로토콜도 있다)
2. 서버에 접속한다 : 클라이언트측의 소켓을 서버측의 소켓에 접속하는 단계이다.
3. 데이터를 송/수신한다 : 프로토콜 스택은 애플리케이션에게 의뢰받은 메시지를 작은 조각(패킷)으로 분할하여 서버를 향해 송신한다. TCP 프로토콜 메시지 송/수신 동작의 다음은 실제 패킷을 보내는 것으로 프로토콜 스택과 LAN 어댑터가 연대하여 패킷을 전기나 빛의 신호로 변환하여 케이블에 송출한다.
4. 서버에서 연결을 끊어 소켓을 말소한다.  

* 소켓을 작성한다  
소켓이란 논리적인 객체이다. 즉 실제 물리적인 어떤 것이 생성되는 것이 아니고 통신에 필요한 다양한 메타 정보를 메모리에 저장하고 이를 소켓이라고 부르는 것이다.  

* 서버에 접속한다  
접속은 서버와 통신할 수 있는 상태가 되는 것이다. 클라이언트의 소켓이 생성되면 소켓 안의 정보로는 통신을 할 수 없다. 브라우저와 같은 어플리케이션은 대상 서버의 URL, 포트와 같은 정보를 가지고 있지만 지금 막 만든 소켓엔 해당 정보가 없다. 마찬가지로 서버측의 소켓도 통신할 클라이언트의 정보를 가지고 있지 않다. 때문에 접속의 첫 번째 동작은 통신 상대와 제어정보룰 주고받아 소켓에 필요한 정보를 기록하여 데이터 송/수신이 가능한 상태로 만드는 것이다.  

* 데이터를 송/수신한다  
어플리케이션이 데이터 송신을 요청하면 프로토콜 스택은 일단 해당 데이터를 내부 버퍼 메모리에 저장한 후 일정 크기가 되면 송신하게 된다. 이 일정 크기는 하나 패킷의 크기와 네트워크 상태에 따라 결정된다. 또한 만약 TCP 프로토콜을 사용한다면 송신한 패킷이 올바르게 서버에 도착했는지 확인하고 도착 안했다면 재전송하는 기능이 있습니다. 전송이 정상적으로 되었음이 확인되면 버퍼 메모리를 비우게 된다. 이를 위해 서버는 패킷을 수신하면 수신을 했다는 응답을 보내게 된다. 이 때 양측은 시퀀스 번호와 ACK 번호를 통해 각 패킷의 전송이 잘 되었는지 여부를 확인하게 된다.  
초기 통신에선 클라이언트가 하나의 패킷을 보내고 정상 수신 응답을 받으면 다음 패킷을 보내는 방식이었기에 통신의 지연이 많았다. 이 문제 개선을 위해 클라이언트는 서버측에 패킷 정상 수신 응답을 기다리지 않고 서버의 수용 가능한 수신 버퍼 크기만큼(통신 시 서버로부터 받는 정보) 바로바로 보내도록 변경이 되었다. 이를 윈도우 제어 방식이라고 한다.  
송신이 끝나면 프로토콜 스택은 응답 데이터를 수신하기 위해 read 상태로 가게 된다. 데이터를 수신하면 데이터가 누락되었는지 검사하고 문제가 없으면 수신이 완료 되었다는 응답을 보내게 된다. 패킷 조각이 하나의 데이터로 완성이 되면 어플리케이션에 전달하게 된다.


      





<br>
<br>
<h4></h4>

<br>
<br>
<h4></h4>

<br>
<br>
<h4></h4>

<br>
<br>
<h4></h4>

<br>
<br>
<h4></h4>

<br>
<br>
<h4></h4>

<br>
<br>
<h4></h4>

<br>
<br>
<h4></h4>

<br>
<br>
<h4></h4>

<br>
<br>
<h4></h4>

<br>
<br>
<h4></h4>

<br>
<br>
<h4></h4>

<br>
<br>
<h4></h4>

<br>
<br>
<h4></h4>

<br>
<br>
<h4></h4>

<br>
<br>
<h4></h4>

<br>
<br>
<h4></h4>

<br>
<br>
<h4></h4>

<br>
<br>
<h4></h4>

<br>
<br>
<h4></h4>

<br>
<br>
<h4></h4>

<br>
<br>
<h4></h4>

